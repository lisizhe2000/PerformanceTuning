# 2023.10.16

### 1. 实现与FLASH的公平比较 —— 不使用SAT求解器生成解，而是直接从csv文件中采样

    实现方式：

    1. 启动方式
        1. 使用DDBS启动采样，增加均匀性
        2. Novelty Search（复杂度较高，假设初始样本集大小为n，总样本集大小m，则复杂度为 m^n ）
        3. FSCS(fixed-size-candidate-set)，即第一次随机选一点，后面每次遍历每个点，挑选出与候选集平均距离最大的     √

    2. 主动学习增量采样方法
        1. 单点采样，每次添加一个最大预测均值的采样点       √
        2. 单点采样，每次添加一个UCB（最大置信上界）最大的点，UCB = mean(x) + k·var(x)
        3. 添加采样点时使用批量采样，增加样本集的多样性以避免局部最优，可以使用NSLC（读一下Spark调优那篇文章）  √
        4. 使用MAP-Elites进行单点采样或批量采样

    3. 在采集函数中引入方差，或取其上界
        1. 随机森林     √
        2. 各种集成学习
        3. 多个异构模型，取最大预测值   （批注：我认为不可行。找不到最优配置的关键不在于模型。模型已经足够精确了，但是是由于性能的测量误差，导致性能不完全遵循模型的描述。关键在于搜索过程中的扰动）

### 2. 发邮件询问一下JVM的Feature Model  
    

# 2023.10.30

### Config类设计

真实性能：

    1. 预先存储型   √
        1.1 存储在树中，每次从树里读
        1.2 直接在pool中拿config，直接拿到
    2. TODO: 真实评估型 
        需要运行真实程序评估性能

# 2023.10.31

### xgboost预测速度太慢，与FLASH比较不公平

    1. 调整xgboost参数
    2. 换其他的机器学习模型
    3. 用FLASH的CART    √

### 增加其他类型的config option

    之前只有bool类型变量，要把bool+数值型的加上来   √

# 2023.11.3

### 新的思路

    配置的测量结果具有一定的浮动性（误差值），没有数学模型能够精确描述这种误差，所以算法捕捉到的SQL的最优配置的rank总是在10  
    我们需要在每次增量采样的过程中增加扰动，使其能够捕捉到次优结果，这是性能突破的关键  
    将距离度量纳入批量采样中，我认为是适合的方法

# 2023.11.13

### 进一步实现公平的比较：

    1. 在sail中添加停止条件
    2. 在flash中设置以最大评估数停止    √

### 自己复现的FLASH效果总是比源码差

    那就先用自己复现的FLASH拿来比较吧

# 2023.11.14

### 使用聚类的方法

    使用聚类的方法，在每个类中去采样

### 实现最小化error rate的算法

    与ComSA进行比较

### 实现在更大的真实模型上跑的

    问一下JVM的Feature Model
    Spark调优